


<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Scaffold Filling</title>
        <style>
        </style>
    </head>
    <body>
  
<script src="./d3.v4.js"></script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_SVG" ></script>
<script src="./pres.js"></script>
<script src="./pres-misc.js"></script>
<script src="./pres-camera.js"></script>
<script src="./pres-codex.js"></script>
<script src="./pres-menu.js"></script>
<script src="./pres-layout.js"></script>
<script src="./pres-text.js"></script>
<script src="./pres-helpLines.js"></script>
<script src="./pres-frameStyle.js"></script>
<script src="./pres-transition.js"></script>
<script src="./pres-graph.js"></script>
<script src="./pres-image.js"></script>
<script src="./pres-pdf.js"></script>
<script src="./pres-writeParser.js"></script>
<script src="./blob-stream.js"></script>
<script src="./pdfkit.js"></script>
<script>
window.addEventListener("load", function(event) {  
fm=frameManager({screenBackground:"black", mathjax:false, math:"testPres-math.json"});
genecolors={
  a: "rgba(167,122,105, 1)",
  b: "rgba(246, 226, 127, 1)",
  c: "rgba(226, 195, 145, 1)",
  d: "rgba(168, 183, 171, 1)",
  e: "rgba(155, 190, 199, 1)"  ,
  "?": "#ebe"
}

var color5Bags = ["#aaf","#faa","#afa","#dda","#d019d9"];


addToCodex("geneNode", "faddingNode", {
   onDraw:function(i,s) {
   
     i.down("circle").style.fill=(genecolors[i.style.label])
     
     codex.simpleNode.onDraw(i);
   }
   
})

addToCodex("filler", "rect", {
  defaultStyle:{stroke:"white", opacity:0, h:1,w:1}   
})
addToCodex("annotatedString", "g", {
   //defaultStyle: {dx:10, dy:0},
   onBuild: function (i) {
     i.length=0;
     var bg = i.append("g");
     var front = i.append("g");
     if (!i.datum) i.datum={dx:10};
     if (typeof i.datum!="object") i.datum={dx:i.datum};
     var h=15;
     
     i.print = function(s) {
       for (var j=0; j<s.length; j++) {
         front.append("svgtext", {x:i.datum.dx*i.length, y:4, text:s[j]})
         i.length++;
       }
       i.appendRect("",{opacity:0}, [0, i.length-1])
       return i;
     }
     i.appendRect = function(id, style, d) {
       var mid = (d[0]+d[1])/2;
       var w= Math.abs(d[1]-d[0]+0.8);
       var rect= bg.append("rect"+(id?"#"+id:""), {x:i.datum.dx*mid, y:0, w:w*i.datum.dx, h:h})
                .set(style)
        rect.appendRect=i.appendRect;
        rect.print=i.print;
        return rect;
     }
   }
   
})


  fm.frame("", {model:"titleFrame"})
    .title`
\size:20{Beyond Adjacency Maximization:}

\size:26{\bold{Scaffold Filling}

for New String Distances}
`
   .append("writer", {align:"c"}).write`
   \color:black, size:13{Laurent Bulteau, CNRS – U-PEM
   Joint work with Christian Komusiewicz and Guillaume Fertin
   IRIF Seminar – 2017-06-20}`
  
  
  
  
  var original =  "abcdadbcdadcbabbc"
   
  fm.frame("Motivation")
    //animation title
    .append("writer#top", {align:"c"}).write`\bold, color:blue{Genome sequencing, in an ideal world}`
    
    //graph and box
    .then("g", {})
     .append("graph#g",{height:null},{nodeType:"geneNode" })
     .setFixedBoundingBox({y:60, height:140})
     
    //base lace   
  var base=fm.goto("#g").addLace("l1",{dx:22},{d:original})
      
    //read laces  
  var reads =    
  [[0,2],[8,2],[3,3],[13,4],[10,2], [5,4],[12,2],[1,4],[9,4]]
   .map(function(ss, i) {      
      return fm.goto("#g")
       .addLace("ss"+i,{dx:22,y:0, x:(ss[0]-(original.length-ss[1])/2)*22},{d:original.substring(ss[0], ss[0]+ss[1])})
   }) 

  fm.nextOverlay() ;
    //show reads
  reads.forEach(function(read,i) {
     var y=8*i+20;
    read.set({y:y, transition:{duration:y*12}})
    read.getSubgraphLinks().set({transition:{duration:y*12}})
  })
    //fade base
  base.set({fadding:0.3, transition:{duration:1000}})
      .getSubgraphLinks().set({opacity:0.3, transition:{duration:1000}})  
      
  fm.nextOverlay() ;
    //show overlap
  var extraLinks=
  [[0,1,7,0], [2,0,7,2],[2,1,7,3],[2,2,5,0],[1,0,5,3],[1,1,8,0],[4,0,8,1],[4,1,8,2],[6,0,8,3],[3,0,6,1]  ]
    .map(function(xlink) {
       return {source:reads[xlink[0]].get(xlink[1]), target:reads[xlink[2]].get(xlink[3])};
    })
    console.log(extraLinks)
  fm.goto("#g")
      .pushLinkStyle({strokeWidth:6, stroke:"green"})
      .addLinks(extraLinks) 
      .saveAs("extraLinks")
      .popLinkStyle()
   
     
  fm.nextOverlay() ;
    //show result
  result=fm.goto("#g").addLace("l2",{y:120, dx:22},{d:original})
   
 
  fm.nextOverlay() 
    .goto("#top").write`
    
    ...and in practice...`
  result.hide();
   fm.goto("#extraLinks").hide();
  errors=
     fm.goto("#g").getNodes(
       [[0,1,"c"],[3,1,"e"], [8,0,"b"],[8,2,"a"]] 
          .map(function(err){
          return reads[err[0]].get(err[1])
                    .set({label:err[2], stroke:"red", strokeWidth:2});    })  
      )
  fm.nextOverlay() 
  fm.goto("#g").getNeighborLinks(errors).intersect(fm.goto("#extraLinks")).set({stroke:"red", opacity:0.3}) 
  fm.goto("#extraLinks").show();
  fm.nextOverlay() 
  result.show();
  result.get(1).hide()
  result.get(9).hide()
  result.get(10).hide()
  result.get(11).hide()
  fm.goto("#g").addNode("?", result.get(1))  
    .goto("#g").addNode("?", result.get(10))
  
  fm.nextOverlay() 
    .append("writer", {align:"c"})
      .write`Assembling noisy reads based on overlap 
      may always leave gaps: 
      Can we do anything more in silico?`
  fm.nextOverlay() 
    .append("writer", {align:"c"})
      .write`\bold{Idea:} use a known genome from a close species to fill-in the gaps`
  
  fm.frame("Modelisation")
    .append("writer")
     .write`-| A \bold{genome} is a string. Characters are interpreted as genes
-| A \bold{scaffold} is an ordered list of strings called \bold{contigs}
-| A \bold{completion} of a scaffold is a concatenation of the contigs 
 using arbitrary intermediate strings
-| Two genomes are \bold{equivalent} if they use the same multi-set 
of letters
     `
     
  .then("titleBox")
    .title("Scaffold Filling Problem")
    .content`
    Given a (reference) genome $G$ and a scaffold $S$, 
    find a completion $S^*$ of $S$, equivalent to $G$, and
    optimizing some measure of similarity $d(S^*, G)$`
    
    
  fm.frame("Measuring genome similarity")
   .append("writer").write`
*|Comparing different species:
   Consider \bold{large-scale rearrangements}: edit distances are useless
*|Some distances \bold{forbid repeated letters}: 
   They may yield efficient algorithms, with strong restriction on the data
   [Muñoz et al., 2010] 
*|Trade-off between computation speed and biological relevance
   ` 
  fm.frame("Distances between genomes")
.append("titleBox", {width:390})
 .title("Number of common adjacencies")
 .content`
Adjacencies of $S$: multiset of length-2 substrings $S[i] S[i+1]$
Common adjacencies of $S_1$ and $S_2$ = intersection of the adjacencies 
of $S_1$ and $S_2$.  `

 .then("writer#w",{align:"c"}).write`
 \array:c{
 $S_1$ &\box#gap{}&$S_2$ //
\box#S1{}& &
\box#S2{} // 
\color:gray{
\on:[0], color:blue{aa}   \on:[4], color:blue{bc}
\on:[0], color:black{aa}   \on:[5], color:black{bd}
\on:[1], color:blue{ab}   \on:[6], color:blue{ca}
\on:[1], color:blue{ab}   \on:[7], color:blue{cb}
\on:[4], color:blue{bc}   
&   &
\on:[0], color:blue{aa}   \on:[4], color:blue{bc}
\on:[1], color:blue{ab}   \on:[4], color:blue{bc}
\on:[1], color:blue{ab}   \on:[6], color:blue{ca}
\on:[2], color:black{ad}   \on:[7], color:blue{cb}
\on:[3], color:black{ba}  }}
 `
 .goto("#gap").append("filler",{w:20})
 .goto("#S1").append("annotatedString")//aa
    .print("aabcaabcbd")
    .appendRect("",{},[0,1]).on([1], {show:false})
    .appendRect("",{},[4,5]).on([1], {show:false})
 .goto("#S2").append("annotatedString")
    .print("abcbaabcad")
    .appendRect("",{},[4,5]).on([1], {show:false})
fm.nextOverlay() //ab
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[1,2]).on([1], {show:false})
    .appendRect("",{},[5,6]).on([1], {show:false})
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[0,1]).on([1], {show:false})
    .appendRect("",{},[5,6]).on([1], {show:false})
fm.nextOverlay() //ad
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[8,9]).on([1], {show:false})
fm.nextOverlay() //ba
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[3,4]).on([1], {show:false})
fm.nextOverlay() 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[2,3]).on([1], {show:false})
    .appendRect("",{},[6,7]).on([1], {show:false})
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[1,2]).on([1], {show:false})
    .appendRect("",{},[6,7]).on([1], {show:false})

fm.nextOverlay() 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[8,9]).on([1], {show:false})    
fm.nextOverlay() 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[3,4]).on([1], {show:false})    
 .goto("#S2").down("annotatedString")
    .appendRect("",{},[7,8]).on([1], {show:false})
fm.nextOverlay() 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[7,8])
 .goto("#S2").down("annotatedString")
    .appendRect("",{},[2,3])
fm.nextOverlay()
  .goto("#w")
    .write`Common adjacencies = 7`;


  fm.frame("Distances between genomes")
.append("titleBox", {width:390})
 .title("Number of common $k$-mers")
 .content`
$k$-mers of $S$: multiset of length-$k$ substrings $S[i]\ldots S[i+k-1]$
Common $k$-mers of $S_1$ and $S_2$ = intersection of the $k$-mers
of $S_1$ and $S_2$.  `

 .then("writer#w",{align:"c"}).write`
 \array:c{
 $S_1$ &\box#gap{}&$S_2$ //
\box#S1{}& &
\box#S2{} // 
\color:gray{
\on:[0], color:blue{aab}   \on:[3], color:blue{bca}
\on:[0], color:black{aab}   \on:[4], color:blue{bcb}
\on:[1], color:blue{abc}   \on:[5], color:black{caa}
\on:[1], color:blue{abc}   \on:[8], color:black{cbd}
&   &
\on:[0], color:blue{aab}   \on:[3], color:blue{bca}
\on:[1], color:blue{abc}   \on:[4], color:blue{bcb}
\on:[1], color:blue{abc}   \on:[6], color:black{cad}
\on:[2], color:black{baa}   \on:[7], color:black{cba}}
}
 `
 .goto("#gap").append("filler",{w:20})
 .goto("#S1").append("annotatedString")
    .print("aabcaabcbd")
    .appendRect("",{},[0,2]).on([1], {show:false})
    .appendRect("",{},[4,6]).on([1], {show:false})
 .goto("#S2").append("annotatedString")
    .print("abcbaabcad")
    .appendRect("",{},[4,6]).on([1], {show:false})
fm.nextOverlay() 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[1,3]).on([1], {show:false})
    .appendRect("",{},[5,7]).on([1], {show:false})
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[0,2]).on([1], {show:false})
    .appendRect("",{},[5,7]).on([1], {show:false})
fm.nextOverlay() 
 .goto("#S2").down("annotatedString")
    .appendRect("",{},[3,5]).on([1], {show:false})    

 fm.nextOverlay() //bca
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[2,4]).on([1], {show:false})    
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[6,8]).on([1], {show:false})

fm.nextOverlay() //bcb
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[6,8]).on([1], {show:false})    
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[1,3]).on([1], {show:false}) 
fm.nextOverlay() //caa 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[3,5]).on([1], {show:false})    
fm.nextOverlay() //cad 
 .goto("#S2").down("annotatedString")
    .appendRect("",{},[7,9]).on([1], {show:false})    
fm.nextOverlay() //cba 
 .goto("#S2").down("annotatedString")
    .appendRect("",{},[2,4]).on([1], {show:false})    
fm.nextOverlay() //cbd 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[7,9])

fm.nextOverlay()
  .goto("#w")
    .write`Common 3-mers = 5`;
    
 fm.frame("Distances between genomes")
.append("titleBox", {width:390})
 .title("String Breakpoint")
 .content`Given a permutation $\pi:[|S_1|]\rightarrow [|S_2|]$, with $S_1[i]=S_2[\pi_i]$ 
 Breakpoint: index $i$ such that $\pi_{i+1}\neq \pi_i +1$
 Breakpoint distance: minimal number of breakpoints over all $\pi$
 `
 .then("graph#g",{height:null})
    .pushLinkStyle({stroke:"none"})
    .setNodeStyle({dragAxis:{x:1,y:0}})
 var l1=fm.goto("#g").addLace("l1",{dx:22, fill:"white"},{d:"aabcaabcbd"});
 var l2=fm.goto("#g").addLace("l2",{dx:22, y:60, fill:"white"},{d:"abcbaabcad"});
 
 fm.nextOverlay();
 
 fm.goto("#g").popLinkStyle().pushLinkStyle({srcTangent:{x:0,y:20}, tgtTangent:{x:0,y:-20}})
  
  var pi=[4,5,6,7,8,0,1,2,3,9];
  pi.forEach(function (j,i) {
    fm.goto("#g").addLink(l1.get(i),l2.get(j));
  })
 fm.nextOverlay();
    l1.get([0,1,2,3,4]).frameNodes("",{margin:2})
    l1.get([5,6,7,8]).frameNodes("",{margin:2})
    l1.get([9]).frameNodes("",{margin:2}) 
    l2.get([0,1,2,3]).frameNodes("",{margin:2})
    l2.get([4,5,6,7,8]).frameNodes("",{margin:2})
    l2.get([9]).frameNodes("",{margin:2})
  
 fm.nextOverlay()
  .append("writer").write`Also known as MCSP: NP-hard to compute`;
  
  
  fm.frame("Example")
   .append("writer").write`
\bold{Scaffold:} &abcb  (?)  aa  (?)  b  (?)  d //
\bold{Reference:} &$G=$ aabcaabcbd//
\bold{Missing genes:} & a, c //
     `
       
     fm.nextOverlay().append("writer#w", {}, {cols:"lc"})
       .write`     &
       $S_1$ = abcb\bold, color:red{c}aa\bold, color:red{a}bd  & 
       $S_2$ = abcbaab\bold, color:red{c}\bold, color:red{a}d  //
       \pause{}Common adjacencies with $G$:&\color:green{9}&7//
       \pause{}Common 3-mers with $G$:&4&\color:green{5}//
       \pause{}Breakpoints with $G$:&4&\color:green{2}//
     `
       
       

  fm.frame("Parameters")
 .append("writer").write`       
.|Some definitions:
 -|\bold{Parameter:} quantity $k$ depending on the instance, 
  a "good" parameter is small for "real-life" instances
 -|\bold{FPT algorithm:} exact algorithm running in time $f(k)n^{O(1)}$
 
 \pause{}
.|Possible parameters:
 -|\color:blue{$t$}: Number of missing characters
 -|\color:blue{$d$}: Maximum occurence of any character
 -|\color:blue{$\ell$}: New adjacencies or $k$-mers  
 -|\color:blue{$b$}: Breakpoints
`

  fm.frame("Results")
   .append("writer").write`       
|\bold{Earlier results:}
.| Length-1 contigs, common adjacencies:
 -| NP-hard [Jiang et al., '11]
 -| FPT for $\ell$ [Bulteau et al., '15]
.| Any contigs, common adjacencies:
 -| NP-hard with 2 contigs [Jiang et al. '16]
 -| FPT for $\ell, d$ [Jiang et al. '16]

|\bold{Our results:}
.|Any contigs, common $k$-mers:
 -|FPT for $\ell, t$
 
`

  fm.frame("Maximizing k-mers", {model:"catST"})
    .subtitle("Color-coding + Dynamic Programming Algorithm")
    
  
   .append("writer#p1").write`\pause{} 
-|Compute missing $k$-mers from $G$  \pause{}\pause{}\pause{}
\color:brown, size:10{An optimal solution uses $\ell$ of them, but we cannot enumerate all $ {n \choose \ell}$ subsets} \pause{}
-|Color-code those $k$-mers with $\ell$ colors \pause{}
\color:brown, size:10{One coloring among $f(\ell)$ separates the new $k$-mers}   
 `
   .then("writer#p2")


 var g="baabcdabccdbabcdabc";  
 
 var s="bca bccd baa abdcbcb";  
 var opt="bcaabccdbaadabdcbcb";  
 var gkmers=[], skmers=[], optkmers=[];
 for (var i=0; i<g.length-2; i++) gkmers.push(g.substring(i,i+3));
 for (var i=0; i<s.length-2; i++) {
   var sm=s.substring(i,i+3);
 //  if (sm.indexOf(" ")==-1) 
 skmers.push(sm);
 }
 for (var i=0; i<s.length-2; i++) {
   var optm=opt.substring(i,i+3);
 //  if (sm.indexOf(" ")==-1) 
   optkmers.push(optm);
 }
 var missing=""; var sp=s.split('');
 for (var i=0;i<g.length; i++) {
   var find=sp.indexOf(g[i])
   console.log(find)
   if (find==-1) 
     missing+=g[i]+" ";
   else sp[find] = "-";
 }
 console.log(sp,g, missing);
 fm.append("horizontalVector#hv")
     .append("vector#left")
       .append("writer").write("Reference:")
       .then("annotatedString#g")
        .print(g)
       .then("writer").write("Scaffold:")
      .then("annotatedString#s")
        .print(s)
        
     .then("writer").write("To insert:")
     
     .then("annotatedString#s2")
         .print(missing)
        
     .then("writer").addTo("optBag").on([0,3], {show:false}).write("Optimal:")     
     .then("annotatedString#opt").addTo("optBag").on([0,3], {show:false})
         .print(opt)
         .appendRect("", {fill:"#aaf", stroke:"none"},[3,3])
         //.appendRect("", {fill:"#f88", stroke:"none"},[8,6])
         .appendRect("", {fill:"#aaf", stroke:"none"},[11,11])
     
 fm.nextOverlay()
   .goto("#hv").append("graph#ckm", {height:150, width:200, active:false},{nodeType:"rectNode", simulation:true})
     .setNodeStyle({w:28, h:15})
    fm.goto("#ckm")
     .simulation().simulation
       .force("charge", null)
       .force("collide").radius(15)
    
    //.simulation().set({active:false})
   function mainBagIndex(i) { return i%5}
   function colora(i) {
     return color5Bags[ mainBagIndex(i)];
   }
   function colorb(i) {
     return color5Bags[Math.floor(i/2)%5];
   }
   function colorc(i) {
     return color5Bags[Math.floor(i/3)%5];
   }
   
   //find common kmers g -- s and g--opt
   gkmers.forEach(function(m, i) {
    var common=skmers.indexOf(m);
    if (common>-1) skmers[common]+=" ";
    var commonOpt=optkmers.indexOf(m);
    if (commonOpt>-1) optkmers[commonOpt]+=" ";
    
    var n=
     fm.goto("#ckm")
       .addNode(i)
       .set({label:m, fill:"#fff"})
    if (common>-1)  {
       n.on([1], {fill:"#ddd"})
        .on([2], {show:false})        
       fm.goto("#s").appendRect("",{showOn:1, opacity:0.2, fill:"black", stroke:"none",offsety:(common%3-1)*2}, [common, common+2])
       fm.goto("#g").appendRect("",{showOn:1, opacity:0.2, fill:"black", stroke:"none",offsety:(i%3-1)*2}, [i, i+2])
    }
    else {       
       //not found in s, is it in opt?       
       if (commonOpt>-1) {
         n.on([4,7], {color: "#880000", weight:"bold"}) 
         
         fm.goto("#opt").appendRect("",{showOn:4, opacity:0.2, fill:"black", stroke:"none",offsety:(commonOpt%3-1)*2}, [commonOpt, commonOpt+2])
           
       } else {
         n.on([4,7],{ opacity:0.5})
       }
       
       n.on(5, {fill: colora(i)})  
        .on(6, {fill: colorb(i)})   
        .on(7, {fill: colorc(i)})          
        .on([8], {fill: colora(i), y:( mainBagIndex(i)-2)*20})  
        .addTo("nodeBag"+( mainBagIndex(i)));
        
    }
       
 })
fm.nextOverlays(8)
  .goto("#optBag").hide()
  .goto("#p1").hide()
  
//fm.nextOverlay()
  .goto("#p2") .write`
  For all \size:12{
&
\color:blue, showOn:[4]{$\mathbf{Q[i, T',C,s]} \Leftrightarrow \exists$ a filling }\size:12{//
*|$i\leq $ number of contigs \pause{}
*|$T' \subseteq T$ \pause{}
*|$C$ subset of colors\pause{}
*|$s$ length-$(k-1)$ string}\pause{}\pause{}&
*|of the first $i$ contigs, that
*|uses exactly the letters in $T'$,
*|creates adjacencies with colors $C$
*|ends with the suffix $s$}`
 
  .goto("#s")
    .appendRect("",{fill:"yellow", stroke:"none"}, [0,8])
fm.nextOverlay()
  .goto("#s2")
    .appendRect("",{fill:"yellow", stroke:"none"}, [2,2])
fm.nextOverlay()
  .goto("#ckm")
    .nodes().set({opacity:0.4})
  .goto("#nodeBag1").set({opacity:1})
  .goto("#nodeBag4").set({opacity:1})
fm.nextOverlay()
  .goto("#left")
  .append("writer").write`\color:blue{$s=$ da}`
fm.nextOverlay()
  .goto("#left")
  .append("annotatedString")
    .decoration("border")
    .print("bcabccda")
    .appendRect("",{fill:colora(1), stroke:"none", opacity:0.7, rx:5, ry:2},[2,4])
    .appendRect("",{fill:colora(4), stroke:"none", opacity:0.7, rx:5, ry:2},[5,7])
    .appendRect("",{fill:"yellow", stroke:"none", opacity:1,h:10},[3,2])
    .appendRect("",{fill:"yellow", stroke:"none", opacity:1, h:10},[7,7])
  
 

  fm.frame("Maximizing k-mers", {model:"catST"})
    .subtitle("Remarks and improvements")
    .append("writer").write`
*|Take $s$ only as factors of reference genome, of length at most $k-1$ 
 >|$|\Sigma|^k \rightarrow nk$
*|$T$ may contain strings rather than single letters
*|Variant: We must insert at most $t$ elements from $T$, 
with extra constraints ("pick at most one in such bag")
  |use color-coding on elements of $T$, with $t$ colors
 >|FPT for $\ell$ and $t<|T|$
*|Overall: $O(n^2 m k^3 \ell 8.16^\ell |T| 5.44^t)$

    
   
   `
 fm.frame("Minimizing the breakpoint distance")
  
  


  

fm.run();
});
</script>
<canvas id="canvas"></canvas>
</body>
</html>
