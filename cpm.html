


<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Scaffold Filling</title>
        <style>
        </style>
    </head>
    <body>
  
<script src="./d3.v4.js"></script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script src="./pres.js"></script>
<script src="./pres-misc.js"></script>
<script src="./pres-camera.js"></script>
<script src="./pres-codex.js"></script>
<script src="./pres-menu.js"></script>
<script src="./pres-layout.js"></script>
<script src="./pres-text.js"></script>
<script src="./pres-helpLines.js"></script>
<script src="./pres-frameStyle.js"></script>
<script src="./pres-transition.js"></script>
<script src="./pres-graph.js"></script>
<script src="./pres-image.js"></script>
<script src="./pres-pdf.js"></script>
<script src="./pres-writeParser.js"></script>
<script src="./blob-stream.js"></script>
<script src="./pdfkit.js"></script>
<script>
window.addEventListener("load", function(event) {  
fm=frameManager({screenBackground:"black", mathjax:false, math:"testPres-math.json"});
genecolors={
  a: "rgba(167,122,105, 1)",
  b: "rgba(246, 226, 127, 1)",
  c: "rgba(226, 195, 145, 1)",
  d: "rgba(168, 183, 171, 1)",
  e: "rgba(155, 190, 199, 1)"  ,
  "?": "#ebe"
}


addToCodex("geneNode", "faddingNode", {
   onDraw:function(i,s) {
   
     i.down("circle").style.fill=(genecolors[i.style.label])
     
     codex.simpleNode.onDraw(i);
   }
   
})


  fm.frame("", {model:"titleFrame"})
    .title`
\size:20{Beyond Adjacency Maximization:}

\size:26{\bold{Scaffold Filling}

for New String Distances}
`
   .append("writer", {align:"c"}).write`
   \color:black, size:13{Laurent Bulteau, CNRS – U-PEM
   Joint work with Christian Komusiewicz and Guillaume Fertin
   IRIF Seminar – 2017-06-20}`
  
  
  
  
  var original =  "abcdadbcdadcbabbc"
   
  fm.frame("Motivation")
    //animation title
    .append("writer#top", {align:"c"}).write`\bold, color:blue{Genome sequencing, in an ideal world}`
    
    //graph and box
    .then("g", {})
     .append("graph#g",{height:null},{nodeType:"geneNode" })
     .setFixedBoundingBox({y:60, height:140})
     
    //base lace   
  var base=fm.goto("#g").addLace("l1",{dx:22},{d:original})
      
    //read laces  
  var reads =    
  [[0,2],[8,2],[3,3],[13,4],[10,2], [5,4],[12,2],[1,4],[9,4]]
   .map(function(ss, i) {      
      return fm.goto("#g")
       .addLace("ss"+i,{dx:22,y:0, x:(ss[0]-(original.length-ss[1])/2)*22},{d:original.substring(ss[0], ss[0]+ss[1])})
   }) 

  fm.nextOverlay() ;
    //show reads
  reads.forEach(function(read,i) {
     var y=8*i+20;
    read.set({y:y, transition:{duration:y*12}})
    read.getSubgraphLinks().set({transition:{duration:y*12}})
  })
    //fade base
  base.set({fadding:0.3, transition:{duration:1000}})
      .getSubgraphLinks().set({opacity:0.3, transition:{duration:1000}})  
      
  fm.nextOverlay() ;
    //show overlap
  var extraLinks=
  [[0,1,7,0], [2,0,7,2],[2,1,7,3],[2,2,5,0],[1,0,5,3],[1,1,8,0],[4,0,8,1],[4,1,8,2],[6,0,8,3],[3,0,6,1]  ]
    .map(function(xlink) {
       return {source:reads[xlink[0]].get(xlink[1]), target:reads[xlink[2]].get(xlink[3])};
    })
    console.log(extraLinks)
  fm.goto("#g")
      .pushLinkStyle({strokeWidth:6, stroke:"green"})
      .addLinks(extraLinks) 
      .saveAs("extraLinks")
      .popLinkStyle()
   
     
  fm.nextOverlay() ;
    //show result
  result=fm.goto("#g").addLace("l2",{y:120, dx:22},{d:original})
   
 
  fm.nextOverlay() 
    .goto("#top").write("\n...and in practice...")
  result.hide();
   fm.goto("#extraLinks").hide();
  errors=
     fm.goto("#g").getNodes(
       [[0,1,"c"],[3,1,"e"], [8,0,"b"],[8,2,"a"]] 
          .map(function(err){
          return reads[err[0]].get(err[1])
                    .set({label:err[2], stroke:"red", strokeWidth:2});    })  
      )
  fm.nextOverlay() 
  fm.goto("#g").getNeighborLinks(errors).intersect(fm.goto("#extraLinks")).set({stroke:"red", opacity:0.3}) 
  fm.goto("#extraLinks").show();
  fm.nextOverlay() 
  result.show();
  result.get(1).hide()
  result.get(9).hide()
  result.get(10).hide()
  result.get(11).hide()
  fm.goto("#g").addNode("?", result.get(1))  
    .goto("#g").addNode("?", result.get(10))
  
  fm.nextOverlay() 
    .append("writer", {align:"c"})
      .write`Assembling noisy reads based on overlap 
      may always leave gaps: 
      Can we do anything more in silico?`
  fm.nextOverlay() 
    .append("writer", {align:"c"})
      .write`\bold{Idea:} use a known genome from a close species to fill-in the gaps`
  
  fm.frame("Modelisation")
    .append("writer")
     .write`
-| A \bold{genome} is a string. Characters are interpreted as genes
-| A \bold{scaffold} is an ordered list of strings called \bold{contigs}
-| A \bold{completion} of a scaffold is a concatenation of the contigs 
 using arbitrary intermediate strings
     `
     
  .then("titleBox", {contfentBG:"#ddd"})
    .title("Scaffold Filling Problem")
    .content`
    Given a (reference) genome $G$ and a scaffold $S$, 
    find a completion $S^*$ of $S$ minimizing $d(S^*, G)$ 
    for some string  distance $d()$`
    
    
  fm.frame("Distances between genome")
   .append("writer").write(`
What distance function $d()$ should we use?

  `
  fm.frame("Maximizing k-mers")
  
  fm.frame("Minimizing the breakpoint distance")
  
  
  

fm.run();
});
</script>
<canvas id="canvas"></canvas>
</body>
</html>
