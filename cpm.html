


<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Scaffold Filling</title>
        <style>
        </style>
    </head>
    <body>
  
<script src="./d3.v4.js"></script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script src="./pres.js"></script>
<script src="./pres-misc.js"></script>
<script src="./pres-camera.js"></script>
<script src="./pres-codex.js"></script>
<script src="./pres-menu.js"></script>
<script src="./pres-layout.js"></script>
<script src="./pres-text.js"></script>
<script src="./pres-helpLines.js"></script>
<script src="./pres-frameStyle.js"></script>
<script src="./pres-transition.js"></script>
<script src="./pres-graph.js"></script>
<script src="./pres-image.js"></script>
<script src="./pres-pdf.js"></script>
<script src="./pres-writeParser.js"></script>
<script src="./blob-stream.js"></script>
<script src="./pdfkit.js"></script>
<script>
window.addEventListener("load", function(event) {  
fm=frameManager({screenBackground:"black", mathjax:false, math:"testPres-math.json"});
genecolors={
  a: "rgba(167,122,105, 1)",
  b: "rgba(246, 226, 127, 1)",
  c: "rgba(226, 195, 145, 1)",
  d: "rgba(168, 183, 171, 1)",
  e: "rgba(155, 190, 199, 1)"  ,
  "?": "#ebe"
}


addToCodex("geneNode", "faddingNode", {
   onDraw:function(i,s) {
   
     i.down("circle").style.fill=(genecolors[i.style.label])
     
     codex.simpleNode.onDraw(i);
   }
   
})

addToCodex("filler", "rect", {
  defaultStyle:{stroke:"white", opacity:0, h:1,w:1}   
})
addToCodex("annotatedString", "g", {
   //defaultStyle: {dx:10, dy:0},
   onBuild: function (i) {
     i.length=0;
     var bg = i.append("g");
     var front = i.append("g");
     if (!i.datum) i.datum={dx:10};
     if (typeof i.datum!="object") i.datum={dx:i.datum};
     var h=15;
     
     i.print = function(s) {
       for (var j=0; j<s.length; j++) {
         front.append("svgtext", {x:i.datum.dx*i.length, y:4, text:s[j]})
         i.length++;
       }
       i.appendRect("",{opacity:0}, [0, i.length-1])
       return i;
     }
     i.appendRect = function(id, style, d) {
       var mid = (d[0]+d[1])/2;
       var w= d[1]-d[0]+0.8;
       var rect= bg.append("rect"+(id?"#"+id:""), {x:i.datum.dx*mid, y:0, w:w*i.datum.dx, h:h})
                .set(style)
        rect.appendRect=i.appendRect;
        rect.print=i.print;
        return rect;
     }
   }
   
})


  fm.frame("", {model:"titleFrame"})
    .title`
\size:20{Beyond Adjacency Maximization:}

\size:26{\bold{Scaffold Filling}

for New String Distances}
`
   .append("writer", {align:"c"}).write`
   \color:black, size:13{Laurent Bulteau, CNRS – U-PEM
   Joint work with Christian Komusiewicz and Guillaume Fertin
   IRIF Seminar – 2017-06-20}`
  
  
  
  
  var original =  "abcdadbcdadcbabbc"
   
  fm.frame("Motivation")
    //animation title
    .append("writer#top", {align:"c"}).write`\bold, color:blue{Genome sequencing, in an ideal world}`
    
    //graph and box
    .then("g", {})
     .append("graph#g",{height:null},{nodeType:"geneNode" })
     .setFixedBoundingBox({y:60, height:140})
     
    //base lace   
  var base=fm.goto("#g").addLace("l1",{dx:22},{d:original})
      
    //read laces  
  var reads =    
  [[0,2],[8,2],[3,3],[13,4],[10,2], [5,4],[12,2],[1,4],[9,4]]
   .map(function(ss, i) {      
      return fm.goto("#g")
       .addLace("ss"+i,{dx:22,y:0, x:(ss[0]-(original.length-ss[1])/2)*22},{d:original.substring(ss[0], ss[0]+ss[1])})
   }) 

  fm.nextOverlay() ;
    //show reads
  reads.forEach(function(read,i) {
     var y=8*i+20;
    read.set({y:y, transition:{duration:y*12}})
    read.getSubgraphLinks().set({transition:{duration:y*12}})
  })
    //fade base
  base.set({fadding:0.3, transition:{duration:1000}})
      .getSubgraphLinks().set({opacity:0.3, transition:{duration:1000}})  
      
  fm.nextOverlay() ;
    //show overlap
  var extraLinks=
  [[0,1,7,0], [2,0,7,2],[2,1,7,3],[2,2,5,0],[1,0,5,3],[1,1,8,0],[4,0,8,1],[4,1,8,2],[6,0,8,3],[3,0,6,1]  ]
    .map(function(xlink) {
       return {source:reads[xlink[0]].get(xlink[1]), target:reads[xlink[2]].get(xlink[3])};
    })
    console.log(extraLinks)
  fm.goto("#g")
      .pushLinkStyle({strokeWidth:6, stroke:"green"})
      .addLinks(extraLinks) 
      .saveAs("extraLinks")
      .popLinkStyle()
   
     
  fm.nextOverlay() ;
    //show result
  result=fm.goto("#g").addLace("l2",{y:120, dx:22},{d:original})
   
 
  fm.nextOverlay() 
    .goto("#top").write("\n...and in practice...")
  result.hide();
   fm.goto("#extraLinks").hide();
  errors=
     fm.goto("#g").getNodes(
       [[0,1,"c"],[3,1,"e"], [8,0,"b"],[8,2,"a"]] 
          .map(function(err){
          return reads[err[0]].get(err[1])
                    .set({label:err[2], stroke:"red", strokeWidth:2});    })  
      )
  fm.nextOverlay() 
  fm.goto("#g").getNeighborLinks(errors).intersect(fm.goto("#extraLinks")).set({stroke:"red", opacity:0.3}) 
  fm.goto("#extraLinks").show();
  fm.nextOverlay() 
  result.show();
  result.get(1).hide()
  result.get(9).hide()
  result.get(10).hide()
  result.get(11).hide()
  fm.goto("#g").addNode("?", result.get(1))  
    .goto("#g").addNode("?", result.get(10))
  
  fm.nextOverlay() 
    .append("writer", {align:"c"})
      .write`Assembling noisy reads based on overlap 
      may always leave gaps: 
      Can we do anything more in silico?`
  fm.nextOverlay() 
    .append("writer", {align:"c"})
      .write`\bold{Idea:} use a known genome from a close species to fill-in the gaps`
  
  fm.frame("Modelisation")
    .append("writer")
     .write`-| A \bold{genome} is a string. Characters are interpreted as genes
-| A \bold{scaffold} is an ordered list of strings called \bold{contigs}
-| A \bold{completion} of a scaffold is a concatenation of the contigs 
 using arbitrary intermediate strings
-| Two genomes are \bold{equivalent} if they use the same multi-set 
of letters
     `
     
  .then("titleBox")
    .title("Scaffold Filling Problem")
    .content`
    Given a (reference) genome $G$ and a scaffold $S$, 
    find a completion $S^*$ of $S$, equivalent to $G$, and
    minimizing $d(S^*, G)$ for some string distance $d()$`
    
    
  fm.frame("Distances between genomes")
   .append("writer").write`
*|Distance between different species:
   Consider \bold{large-scale rearrangements}: edit distances are useless
*|Some distances \bold{forbid repeated letters}: 
   They may yield efficient algorithms, with strong restriction on the data
   [Muñoz et al., 2010] 
*|Trade-off between computation speed and biological relevance
   ` 
  fm.frame("Distances between genomes")
.append("titleBox", {width:390})
 .title("Number of common adjacencies")
 .content`
Adjacencies of $S$: multiset of length-2 substrings $S[i] S[i+1]$
Common adjacencies of $S_1$ and $S_2$ = intersection of the adjacencies 
of $S_1$ and $S_2$.  `

 .then("writer",{align:"c"}).write`
 \array:c{
 $S_1$ &\box#gap{}&$S_2$ //
\box#S1{}& &
\box#S2{} // 
aa   bc 
\color:gray{aa}   \color:gray{bd}
ab   ca
ab   cb
bc
&  & 
aa   bc
ab   bc
ab   ca
\color:gray{ad}   cb
\color:gray{ba}}
Common adjacencies = 7
 `
 .goto("#gap").append("filler",{w:20})
 .goto("#S1").append("annotatedString")
    .print("aabcaabcbd")
    .appendRect("",{},[0,1]).on([1], {show:false})
    .appendRect("",{},[4,5]).on([1], {show:false})
 .goto("#S2").append("annotatedString")
    .print("abcbaabcad")
    .appendRect("",{},[4,5]).on([1], {show:false})
fm.nextOverlay() 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[1,2]).on([1], {show:false})
    .appendRect("",{},[5,6]).on([1], {show:false})
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[0,1]).on([1], {show:false})
    .appendRect("",{},[5,6]).on([1], {show:false})
fm.nextOverlay() 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[2,3]).on([1], {show:false})
    .appendRect("",{},[6,7]).on([1], {show:false})
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[1,2]).on([1], {show:false})
    .appendRect("",{},[6,7]).on([1], {show:false})

fm.nextOverlay() 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[8,9]).on([1], {show:false})    
fm.nextOverlay() 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[3,4]).on([1], {show:false})    
 .goto("#S2").down("annotatedString")
    .appendRect("",{},[7,8]).on([1], {show:false})
fm.nextOverlay() 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[7,8])
 .goto("#S2").down("annotatedString")
    .appendRect("",{},[2,3])



  fm.frame("Distances between genomes")
.append("titleBox", {width:390})
 .title("Number of common $k$-mers")
 .content`
$k$-mers of $S$: multiset of length-$k$ substrings $S[i]\ldots S[i+k-1]$
Common $k$-mers of $S_1$ and $S_2$ = intersection of the $k$-mers
of $S_1$ and $S_2$.  `

 .then("writer",{align:"c"}).write`
 \array:c{
 $S_1$ &\box#gap{}&$S_2$ //
\box#S1{}& &
\box#S2{} // 
aab   bca
\color:gray{aab}   bcb 
abc   \color:gray{caa}
abc   \color:gray{cbd}
&   &
aab   bca
abc   bcb
abc   \color:gray{cad}
\color:gray{baa}   \color:gray{cba}}
Common 3-mers = 5
 `
 .goto("#gap").append("filler",{w:20})
 .goto("#S1").append("annotatedString")
    .print("aabcaabcbd")
    .appendRect("",{},[0,2]).on([1], {show:false})
    .appendRect("",{},[4,6]).on([1], {show:false})
 .goto("#S2").append("annotatedString")
    .print("abcbaabcad")
    .appendRect("",{},[4,6]).on([1], {show:false})
fm.nextOverlay() 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[1,3]).on([1], {show:false})
    .appendRect("",{},[5,7]).on([1], {show:false})
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[0,2]).on([1], {show:false})
    .appendRect("",{},[5,7]).on([1], {show:false})
fm.nextOverlay() 
 .goto("#S2").down("annotatedString")
    .appendRect("",{},[3,5]).on([1], {show:false})    

 fm.nextOverlay() //bca
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[2,4]).on([1], {show:false})    
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[6,8]).on([1], {show:false})

fm.nextOverlay() //bcb
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[6,8]).on([1], {show:false})    
  .goto("#S2").down("annotatedString")
    .appendRect("",{},[1,3]).on([1], {show:false}) 
fm.nextOverlay() //caa 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[3,5]).on([1], {show:false})    
fm.nextOverlay() //cad 
 .goto("#S2").down("annotatedString")
    .appendRect("",{},[7,9]).on([1], {show:false})    
fm.nextOverlay() //cba 
 .goto("#S2").down("annotatedString")
    .appendRect("",{},[2,4]).on([1], {show:false})    
fm.nextOverlay() //cbd 
 .goto("#S1").down("annotatedString")
    .appendRect("",{},[7,9])

    
 fm.frame("Distances between genomes")
.append("titleBox", {width:390})
 .title("String Breakpoint")
 .content`Given a permutation $\pi:[|S_1|]\rightarrow [|S_2|]$, with $S_1[i]=S_2[\pi_i]$ 
 Breakpoint: index $i$ such that $\pi_{i+1}\neq \pi_i +1$
 Breakpoint distance: minimal number of breakpoints over all $\pi$
 `
 .then("graph#g",{height:null})
    .pushLinkStyle({stroke:"none"})
    .setNodeStyle({dragAxis:{x:1,y:0}})
 var l1=fm.goto("#g").addLace("l1",{dx:22, fill:"white"},{d:"aabcaabcbd"});
 var l2=fm.goto("#g").addLace("l2",{dx:22, y:60, fill:"white"},{d:"abcbaabcad"});
 
 fm.nextOverlay();
    l1.get([0,1,2,3,4]).frameNodes("",{margin:2})
    l1.get([5,6,7,8]).frameNodes("",{margin:2})
    l1.get([9]).frameNodes("",{margin:2}) 
    l2.get([0,1,2,3]).frameNodes("",{margin:2})
    l2.get([4,5,6,7,8]).frameNodes("",{margin:2})
    l2.get([9]).frameNodes("",{margin:2})
  fm.goto("#g").popLinkStyle().pushLinkStyle({srcTangent:{x:0,y:20}, tgtTangent:{x:0,y:-20}})
  
  var pi=[4,5,6,7,8,0,1,2,3,9];
  pi.forEach(function (j,i) {
    fm.goto("#g").addLink(l1.get(i),l2.get(j));
  })
  
 fm.nextOverlay()
  .append("writer").write`Also known as MCSP: NP-hard to compute`;
  fm.frame("Example")
   .append("writer").write`
\bold{Scaffold:} &abcb  (?)  aa  (?)  b  (?)  d //
\bold{Reference:} &$G=$ aabcaabcbd//
\bold{Missing genes:} & a, c //
     `
       
     fm.nextOverlay().append("writer#w", {}, {cols:"lc"})
       .write`
       &$S_1$ = abcb\bold, color:red{c}aa\bold, color:red{a}bd & 
       $S_2$ = abcbaab\bold, color:red{c}\bold, color:red{a}d //Common adjacencies with $G$:&\color:green{9}&7 //`
     fm.nextOverlay().goto("#w")
       .write`Common adjacencies with $G$:&\color:green{9}&7 //`
     fm.nextOverlay().goto("#w")
       .write`Common 3-mers with $G$:&4&\color:green{5} //`
       
     fm.nextOverlay().goto("#w")
       .write`Breakpoints with $G$:&4&\color:green{2} //`
       
  fm.frame("Maximizing k-mers")
  
  fm.frame("Minimizing the breakpoint distance")
  
  


  

fm.run();
});
</script>
<canvas id="canvas"></canvas>
</body>
</html>
