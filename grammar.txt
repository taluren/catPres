Input=  String

//Global string: always assume that it starts with '\n'; 
//remove empty lines and start reading
String = skipStartEmptyLines str:(content) {return str;}

//content aggregates contentUnits: successive characters are joined into strings
content = inside:contentUnit* {
    var str="";
    var out=[];
    inside.forEach(function(unit) {
      if (typeof unit=="string") {
        str+=unit;
      } else {
        out.push(str);
        out.push(unit);
        str="";
      }
    });
    out.push(str);
    return out;
  }

// Main unit of the parser: can be single character, a  new line, 
// a whole block with header and parenthesis, etc.
contentUnit=
    block
    /mathBlock
    /arrayToken
    /newLineToken
    /commentBlock
    /otherChar

//a block such as \header{..anything..}
block = open:open str:content close:close {return {param:open.param, id:open.id, inside:str}}

//deals with the opening part of a block: "\params #id{"
open= (escape b:paramStr id:maybeId openChar {return {param:b, id:id}})/(openChar {return {param:null, id:null}})

//optional id, of the form #id
maybeId = id/""
id = "#" id:idChar* {return id.join("")}

openChar="{"

//sequence of parameters
paramStr=  _ s:paramSequence _ {return s} / _
paramSequence = severalParamPairs / singleParamPair
severalParamPairs = x:(keyValue/someKeyword/keyNoValue) _ "," _ y:paramSequence {y[x[0]]=x[1]; return y}
singleParamPair = x:(keyValue/someKeyword/keyNoValue) {var  y={}; y[x[0]]=x[1]; return y}
keyValue = a:(paramChar+) _ ":" _ b:paramValue {return [a.join(''), b]}
keyNoValue = a:(paramChar+) {return [a.join(''), true]}
paramValue = 
 dquote b:((paramChar/" ")+) dquote {return b.join('')}
 / b:((paramChar)+) {return b.join('')}
paramChar=[a-zA-Z0-9_\[\]\-]
idChar=[a-zA-Z0-9_]
dquote='"'
//recognize some keywords automaticaly
someKeyword = 
  ("bold"/"textbf") {return ["weight","bold"]}
  / c:("sans"/"serif") {return ["font",c]}
  

//deals with closing side of a block
close=closeChar {return "[[close]]"} 
closeChar="}" 

//blocks are complete.

//other unit: math content: $...$

mathBlock = mathChar content:mathContent mathChar {return {math:content}}
mathContent = math:((!mathChar) c:. {return c})* {return math.join('')} 
mathChar= "$"

//array tokens, with & and //
//ignore new lines between character and rest of the text
arrayToken = c:arrayChar indenter:newParagraphIndenter {return {array:c, indenter:indenter}}
arrayChar = ("&"/"//")

//new line

newLineToken = "\n" indenter:indenter {return {newline:true, indenter:indenter}}

//comment (starts with %)
commentBlock = commentChar ((!'\n') .)* '\n'? {return ""}
commentChar= "%"
  
//indents and skipping empty lines  
newParagraphIndenter = skipEmptyLines  indenter:indenter {return indenter}
skipEmptyLines = (_ '\n')*
skipStartEmptyLines =  ('\n' _  & '\n')*  ('\n' !fullIndenter)?
indenter = fullIndenter/spaceIndenter

fullIndenter = indent:(indentChar*) id:maybeId endOfIndent
              {return {indent:indent.join(''), id:id, spaceAfter:null}}
                          
spaceIndenter = sp:_ {return {indent:null, id:"", spaceAfter:sp}}
           
indentChar=(! (endOfIndent/simpleNewLine/escape)) c:otherChar {return c}
endOfIndent = "|"
simpleNewLine = "\n" sp:_ {return {newline:{indent:null}, spaceAfter:sp}}

//basic characters
otherChar = !open!close c:(escapedChar / simpleChar) {return c}
simpleChar = !special c:. {return c} 
escapedChar = escape  c:special {return c}
escape = "\\"
special = [#&]/openChar/closeChar/mathChar/arrayChar/commentChar

_ "space"= s:space* {return s.join('')}
space =[ \t]